/*
    TicTacToeBasicComputerPlayer.cpp
    

*/
//----------------------------------------
//TicTacToeBasicComputerPlayer.cpp generated by cbtek on 07-12-2017 at 03:53:51 PM
//----------------------------------------
#include "TicTacToeBasicComputerPlayer.h"

#include <set>

namespace pf_projects {
namespace products {
namespace tic_tac_toe {
namespace players {


TicTacToeBasicComputerPlayer::TicTacToeBasicComputerPlayer()
{ 
}

TicTacToePlayerType TicTacToeBasicComputerPlayer::getPlayerType() const
{
    return TicTacToePlayerType::BasicComputer;
}

TicTacToePlayResultType TicTacToeBasicComputerPlayer::play(int &rowOut,
                                                              int &columnOut,
                                                              const TicTacToeBoard &currentBoard)
{
    //Loop over all cells and store empty ones in validCellPositions
    std::vector<std::pair<int,int> > validCellPositions = currentBoard.getEmptyCellPositions();

    //The following algorithm is used for the TicTacToe computer opponent.
    //Loop over all result types in following order:
    //1st - See if player can win (return if true, continue if false)
    //2nd - See if player can block (return if true, continue if false)
    //3rd - See if player can play random cell (return if true, continue if false)
    for (size_t a1 = 0; a1 < static_cast<int>(TicTacToePlayResultType::NoMoreMovesPlay); ++a1)
    {
        TicTacToePlayResultType algorithm = static_cast<TicTacToePlayResultType>(a1);
        for(const auto& cellPos : validCellPositions)
        {
             int row = cellPos.first;
             int column = cellPos.second;
            try
            {                
                //check horizontal
                if ((column == 0 && updatePlay(algorithm,row,column,row,1,row,2,validCellPositions,rowOut,columnOut,currentBoard)) ||
                    (column == 1 && updatePlay(algorithm,row,column,row,0,row,2,validCellPositions,rowOut,columnOut,currentBoard)) ||
                    (column == 2 && updatePlay(algorithm,row,column,row,0,row,1,validCellPositions,rowOut,columnOut,currentBoard)))
                {
                    return algorithm;
                }

                //check vertical
                if ((row == 0 && updatePlay(algorithm,row,column,1,column,2,column,validCellPositions,rowOut,columnOut,currentBoard)) ||
                    (row == 1 && updatePlay(algorithm,row,column,0,column,2,column,validCellPositions,rowOut,columnOut,currentBoard)) ||
                    (row == 2 && updatePlay(algorithm,row,column,0,column,1,column,validCellPositions,rowOut,columnOut,currentBoard)))
                {
                    return algorithm;
                }

                //check left diagnal
                if ((row == 0 && column == 0 && updatePlay(algorithm,row,column,1,1,2,2,validCellPositions,rowOut,columnOut,currentBoard)) ||
                    (row == 1 && column == 1 && updatePlay(algorithm,row,column,0,0,2,2,validCellPositions,rowOut,columnOut,currentBoard)) ||
                    (row == 2 && column == 2 && updatePlay(algorithm,row,column,0,0,1,1,validCellPositions,rowOut,columnOut,currentBoard)))
                {
                    return algorithm;
                }

                //check right diagnal
                if ((row == 0 && column == 2 && updatePlay(algorithm,row,column,1,1,2,0,validCellPositions,rowOut,columnOut,currentBoard)) ||
                    (row == 1 && column == 1 && updatePlay(algorithm,row,column,0,2,2,0,validCellPositions,rowOut,columnOut,currentBoard)) ||
                    (row == 2 && column == 0 && updatePlay(algorithm,row,column,0,2,1,1,validCellPositions,rowOut,columnOut,currentBoard)))
                {
                    return algorithm;
                }
            }
            catch(...)
            {
                continue;
            }
        }
    }
    return TicTacToePlayResultType::NoMoreMovesPlay;
}

bool TicTacToeBasicComputerPlayer::updatePlay(TicTacToePlayResultType resultType,
                                         int sourceRow,
                                         int sourceColumn,
                                         int firstRow,
                                         int firstColumn,
                                         int secondRow,
                                         int secondColumn,                                         
                                         const std::vector<std::pair<int, int> > &validCellPositions,
                                         int &rowOut,
                                         int &columnOut,
                                         const TicTacToeBoard &currentBoard)
{
    //See if player can win with one move
    if (resultType == TicTacToePlayResultType::WinningPlay &&
        playToWin(sourceRow,
                  sourceColumn,
                  firstRow,
                  firstColumn,
                  secondRow,
                  secondColumn,
                  rowOut,
                  columnOut,
                  currentBoard) == resultType)
    {
        return true;
    }

    //See if player can block other player from winning with one move
    else if (resultType == TicTacToePlayResultType::BlockingPlay &&
             playToBlock(sourceRow,
                         sourceColumn,
                         firstRow,
                         firstColumn,
                         secondRow,
                         secondColumn,
                         rowOut,
                         columnOut,
                         currentBoard) == resultType)
    {
        return true;
    }
    //See if player can randomly place a token
    else if (resultType == TicTacToePlayResultType::RandomPlay &&
             playRandomly(validCellPositions,
                          rowOut,
                          columnOut,
                          currentBoard) == resultType)
    {
        return true;
    }

    //Return false if top 3 conditions can not be met.
    return false;
}


TicTacToePlayResultType TicTacToeBasicComputerPlayer::playToWin(int row1,
                                                     int column1,
                                                     int row2,
                                                     int column2,
                                                     int row3,
                                                     int column3,
                                                     int &rowOut,
                                                     int &columnOut,
                                                     const TicTacToeBoard &currentBoard) const
{
    TicTacToeCell otherCell1 = currentBoard.getCell(row2,column2);
    TicTacToeCell otherCell2 = currentBoard.getCell(row3,column3);

    //Check for winning condition
    if (otherCell1.getCellClass() == getPlayerClass() &&
        otherCell2.getCellClass() == getPlayerClass())
    {
        rowOut = row1;
        columnOut = column1;
        return TicTacToePlayResultType::WinningPlay;
    }
    return TicTacToePlayResultType::NoMoreMovesPlay;
}

TicTacToePlayResultType TicTacToeBasicComputerPlayer::playToBlock(int row1,
                                                       int column1,
                                                       int row2,
                                                       int column2,
                                                       int row3,
                                                       int column3,
                                                       int &rowOut,
                                                       int &columnOut,
                                                       const TicTacToeBoard &currentBoard) const
{
    TicTacToeCell otherCell1 = currentBoard.getCell(row2,column2);
    TicTacToeCell otherCell2 = currentBoard.getCell(row3,column3);

    //Check for blocking condition
    if (otherCell1.getCellClass() != getPlayerClass() &&
        otherCell2.getCellClass() != getPlayerClass() &&
        otherCell1.getCellClass() != TicTacToePlayerClass::None &&
        otherCell2.getCellClass() != TicTacToePlayerClass::None)
    {
        rowOut = row1;
        columnOut = column1;
        return TicTacToePlayResultType::BlockingPlay;
    }
    return TicTacToePlayResultType::NoMoreMovesPlay;
}

TicTacToePlayResultType TicTacToeBasicComputerPlayer::playRandomly(const std::vector<std::pair<int,int> > &validCellPositions,
                                                        int &rowOut,
                                                        int &columnOut,
                                                        const TicTacToeBoard &currentBoard) const
{
    int selectedRow = 0;
    int selectedColumn = 0;
    //Check for possibility of random play
    if (getRandomAvailableCellPosition(selectedRow,selectedColumn,currentBoard))
    {
        rowOut = selectedRow;
        columnOut = selectedColumn;
        return TicTacToePlayResultType::RandomPlay;
    }
    return TicTacToePlayResultType::NoMoreMovesPlay;
}

bool TicTacToeBasicComputerPlayer::getRandomAvailableCellPosition(int &rowOut,
                                                                  int &columnOut,
                                                                  const TicTacToeBoard &currentBoard) const
{

    //Grab all empty cells
    std::vector<std::pair<int,int> > emptyCellPositions = currentBoard.getEmptyCellPositions();

    //No more spaces left on board. End of game
    if (emptyCellPositions.empty())
    {
        return false;
    }

    int min = 0;
    int max = static_cast<int>(emptyCellPositions.size()) - 1;
    int selectedRandomPosition = 0;
    if (min < max)
    {
        selectedRandomPosition = m_random.next(min,max);
    }
    rowOut = emptyCellPositions[selectedRandomPosition].first;
    columnOut = emptyCellPositions[selectedRandomPosition].second;
    return true;
}

TicTacToeBasicComputerPlayer::~TicTacToeBasicComputerPlayer()
{

}

}}}}//end namespace


