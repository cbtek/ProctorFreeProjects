/*
    TicTacToeAdvancedComputerPlayer.cpp
    

*/
//----------------------------------------
//TicTacToeAdvancedComputerPlayer.cpp generated by cbtek on 07-12-2017 at 03:53:51 PM
//----------------------------------------
#include "TicTacToeAdvancedComputerPlayer.h"

#include <set>

namespace pf_projects {
namespace products {
namespace tic_tac_toe {
namespace players {


TicTacToeAdvancedComputerPlayer::TicTacToeAdvancedComputerPlayer()
{ 
}

TicTacToePlayerType TicTacToeAdvancedComputerPlayer::getPlayerType() const
{
    return TicTacToePlayerType::AdvancedComputer;
}

TicTacToePlayResultType TicTacToeAdvancedComputerPlayer::play(int &rowOut,
                                                              int &columnOut,
                                                              const TicTacToeBoard &currentBoard)
{
//    int row,column;
//    if (!getRandomAvailableCellPosition(row,column,currentBoard))
//    {
//        rowOut = -1;
//        columnOut = -1;
//        return TicTacToePlayResultType::NoMoreMovesPlay;
//    }
    std::vector<std::pair<int,int> > validCellPositions;

    for (size_t r = 0; r < 3; ++r)
    {
        for (size_t c = 0; c < 3; ++c)
        {
            const TicTacToeCell &cell = currentBoard.getCell(r,c);
            if (cell.getCellClass() == TicTacToePlayerClass::NoPlayer)
            {
                validCellPositions.push_back(std::make_pair(r,c));
            }
        }
    }

    for (size_t a1 = 0; a1 < static_cast<int>(TicTacToePlayResultType::NoMoreMovesPlay); ++a1)
    {
        TicTacToePlayResultType algorithm = static_cast<TicTacToePlayResultType>(a1);
        for(const auto& cellPos : validCellPositions)
        {
             int row = cellPos.first;
             int column = cellPos.second;

            try
            {                
                //horizontal
                if ((column == 0 && updatePlay(algorithm,row,column,row,1,row,2,validCellPositions,rowOut,columnOut,currentBoard)) ||
                    (column == 1 && updatePlay(algorithm,row,column,row,0,row,2,validCellPositions,rowOut,columnOut,currentBoard)) ||
                    (column == 2 && updatePlay(algorithm,row,column,row,0,row,1,validCellPositions,rowOut,columnOut,currentBoard)))
                {
                    return algorithm;
                }

                //vertical
                if ((row == 0 && updatePlay(algorithm,row,column,1,column,2,column,validCellPositions,rowOut,columnOut,currentBoard)) ||
                    (row == 1 && updatePlay(algorithm,row,column,0,column,2,column,validCellPositions,rowOut,columnOut,currentBoard)) ||
                    (row == 2 && updatePlay(algorithm,row,column,0,column,1,column,validCellPositions,rowOut,columnOut,currentBoard)))
                {
                    return algorithm;
                }

                //Left diagnal
                if ((row == 0 && column == 0 && updatePlay(algorithm,row,column,1,1,2,2,validCellPositions,rowOut,columnOut,currentBoard)) ||
                    (row == 1 && column == 1 && updatePlay(algorithm,row,column,0,0,2,2,validCellPositions,rowOut,columnOut,currentBoard)) ||
                    (row == 2 && column == 2 && updatePlay(algorithm,row,column,0,0,1,1,validCellPositions,rowOut,columnOut,currentBoard)))
                {
                    return algorithm;
                }

                //Right diagnal
                if ((row == 0 && column == 2 && updatePlay(algorithm,row,column,1,1,2,0,validCellPositions,rowOut,columnOut,currentBoard)) ||
                    (row == 1 && column == 1 && updatePlay(algorithm,row,column,0,2,2,0,validCellPositions,rowOut,columnOut,currentBoard)) ||
                    (row == 2 && column == 0 && updatePlay(algorithm,row,column,0,2,1,1,validCellPositions,rowOut,columnOut,currentBoard)))
                {
                    return algorithm;
                }
            }
            catch(...)
            {
                continue;
            }
        }
    }
    return TicTacToePlayResultType::NoMoreMovesPlay;
}

bool TicTacToeAdvancedComputerPlayer::updatePlay(TicTacToePlayResultType algorithm,
                                         int sourceRow,
                                         int sourceColumn,
                                         int firstRow,
                                         int firstColumn,
                                         int secondRow,
                                         int secondColumn,                                         
                                         const std::vector<std::pair<int, int> > &validCellPositions,
                                         int &rowOut,
                                         int &columnOut,
                                         const TicTacToeBoard &currentBoard)
{
    if (algorithm == TicTacToePlayResultType::WinningPlay &&
        playToWin(sourceRow,
                  sourceColumn,
                  firstRow,
                  firstColumn,
                  secondRow,
                  secondColumn,
                  rowOut,
                  columnOut,
                  currentBoard) == algorithm)
    {
        return true;
    }
    else if (algorithm == TicTacToePlayResultType::BlockingPlay &&
             playToBlock(sourceRow,
                         sourceColumn,
                         firstRow,
                         firstColumn,
                         secondRow,
                         secondColumn,
                         rowOut,
                         columnOut,
                         currentBoard) == algorithm)
    {
        return true;
    }
    else if (algorithm == TicTacToePlayResultType::RandomPlay &&
             playRandomly(validCellPositions,
                          rowOut,
                          columnOut,
                          currentBoard) == algorithm)
    {
        return true;
    }
    return false;
}


TicTacToePlayResultType TicTacToeAdvancedComputerPlayer::playToWin(int row1,
                                                     int column1,
                                                     int row2,
                                                     int column2,
                                                     int row3,
                                                     int column3,
                                                     int &rowOut,
                                                     int &columnOut,
                                                     const TicTacToeBoard &currentBoard) const
{
    TicTacToeCell otherCell1 = currentBoard.getCell(row2,column2);
    TicTacToeCell otherCell2 = currentBoard.getCell(row3,column3);

    //Check for winning condition
    if (otherCell1.getCellClass() == getPlayerClass() &&
        otherCell2.getCellClass() == getPlayerClass())
    {
        rowOut = row1;
        columnOut = column1;
        return TicTacToePlayResultType::WinningPlay;
    }
    return TicTacToePlayResultType::NoMoreMovesPlay;
}

TicTacToePlayResultType TicTacToeAdvancedComputerPlayer::playToBlock(int row1,
                                                       int column1,
                                                       int row2,
                                                       int column2,
                                                       int row3,
                                                       int column3,
                                                       int &rowOut,
                                                       int &columnOut,
                                                       const TicTacToeBoard &currentBoard) const
{
    TicTacToeCell otherCell1 = currentBoard.getCell(row2,column2);
    TicTacToeCell otherCell2 = currentBoard.getCell(row3,column3);

    //Check for blocking condition
    if (otherCell1.getCellClass() != getPlayerClass() &&
        otherCell2.getCellClass() != getPlayerClass() &&
        otherCell1.getCellClass() != TicTacToePlayerClass::NoPlayer &&
        otherCell2.getCellClass() != TicTacToePlayerClass::NoPlayer)
    {
        rowOut = row1;
        columnOut = column1;
        return TicTacToePlayResultType::BlockingPlay;
    }
    return TicTacToePlayResultType::NoMoreMovesPlay;
}

TicTacToePlayResultType TicTacToeAdvancedComputerPlayer::playToOutsmart(
                                                          int row1,
                                                          int column1,
                                                          int &rowOut,
                                                          int &columnOut,
                                                          const TicTacToeBoard &currentBoard) const
{
         TicTacToeCell sourceCell = currentBoard.getCell(row1,column1);
         TicTacToeCell centerCell = currentBoard.getCell(1,1);

         TicTacToeCell otherCell1 = currentBoard.getCell(2,2);
         TicTacToeCell otherCell2 = currentBoard.getCell(0,1);
         TicTacToeCell otherCell3 = currentBoard.getCell(2,0);
         TicTacToeCell otherCell4 = currentBoard.getCell(0,0);

//         if (centerCell.getCellClass() == getPlayerClass() &&
//             row1 == )
//         {

//         }



}


TicTacToePlayResultType TicTacToeAdvancedComputerPlayer::playRandomly(const std::vector<std::pair<int,int> > &validCellPositions,
                                                        int &rowOut,
                                                        int &columnOut,
                                                        const TicTacToeBoard &currentBoard) const
{
    int selectedRow = 0;
    int selectedColumn = 0;
    if (getRandomAvailableCellPosition(selectedRow,selectedColumn,currentBoard))
    {
        rowOut = selectedRow;
        columnOut = selectedColumn;
        return TicTacToePlayResultType::RandomPlay;
    }
    return TicTacToePlayResultType::NoMoreMovesPlay;
}

bool TicTacToeAdvancedComputerPlayer::getRandomAvailableCellPosition(int &rowOut,
                                                             int &columnOut,                                                                 
                                                             const TicTacToeBoard &currentBoard) const
{
    std::vector<std::pair<int,int> > emptyCellPositions;
    for(const auto &cell : currentBoard.getCells())
    {
        int row = cell.getRow();
        int column = cell.getColumn();
        if (cell.getCellClass() == TicTacToePlayerClass::NoPlayer)
        {
            emptyCellPositions.push_back(std::make_pair(row,column));
        }
    }

    //No more spaces left on board. End of game
    if (emptyCellPositions.empty())
    {
        return false;
    }

    int min = 0;
    int max = static_cast<int>(emptyCellPositions.size()) - 1;
    int selectedRandomPosition = 0;
    if (min < max)
    {
        selectedRandomPosition = m_random.next(min,max);
    }
    rowOut = emptyCellPositions[selectedRandomPosition].first;
    columnOut = emptyCellPositions[selectedRandomPosition].second;
    return true;
}

TicTacToeAdvancedComputerPlayer::~TicTacToeAdvancedComputerPlayer()
{

}

}}}}//end namespace


