/*
    TicTacToeComputerPlayer.cpp
    

*/
//----------------------------------------
//TicTacToeComputerPlayer.cpp generated by cbtek on 07-12-2017 at 03:53:51 PM
//----------------------------------------
#include "TicTacToeComputerPlayer.h"

#include <set>

namespace pf_projects {
namespace products {
namespace tic_tac_toe {
namespace player_types {


TicTacToeComputerPlayer::TicTacToeComputerPlayer()
{

}

TicTacToePlayerType TicTacToeComputerPlayer::getPlayerType() const
{
    return TicTacToePlayerType::Computer;
}

void TicTacToeComputerPlayer::play(TicTacToeBoard &currentBoard)
{

    int row, column;
    if (!getRandomAvailableCellPosition(row,column,currentBoard))
    {
        return; //no more plays
    }
    std::vector<std::pair<int,int> > validCellPositions;

    //Get surrounding extents of current position
    int c1 = column - 1;
    int c2 = column;
    int c3 = column + 1;

    int r1 = row - 1;
    int r2 = row;
    int r3 = row + 1;

    //top-left of current position
    if (c1 > -1 && r1 > -1) validCellPositions.push_back(std::make_pair(r1,c1));

    //top of current position
    if (r1 > -1) validCellPositions.push_back(std::make_pair(r1,c2));

    //top-right of current position
    if (c3 < 3 && r1 > -1) validCellPositions.push_back(std::make_pair(r1,c3));

    //left of current position
    if (c1 > -1) validCellPositions.push_back(std::make_pair(r2,c1));

    //right of current position
    if (c3 < 3) validCellPositions.push_back(std::make_pair(r2,c3));

    //bottom-left of current position
    if (c1 > -1 && r3 < 3)validCellPositions.push_back(std::make_pair(r3,c1));

    //bottom of current position
    if (r3 < 3)validCellPositions.push_back(std::make_pair(r3,c2));

    //bottom-right of current position
    if (c3 < 3 && r3 < 3)validCellPositions.push_back(std::make_pair(r3,c3));


    for (size_t a1 = 0; a1 < static_cast<int>(TicTacToeAlgorithmMoveType::NoMove); ++a1)
    {
        TicTacToeAlgorithmMoveType algorithm = static_cast<TicTacToeAlgorithmMoveType>(a1);
        for(const auto& cellPos : validCellPositions)
        {
            int row = cellPos.first;
            int column = cellPos.second;

            try
            {
                const TicTacToeCell& cell = currentBoard.getCell(row, column);

                if (cell.getCellClass() == TicTacToePlayerClass::NoPlayer)
                {
                    //horizontal
                    if (column == 0)
                    {
                        updatePlay(algorithm,row,column,row,1,row,2,validCellPositions,currentBoard);
                    }
                    else if (column == 1)
                    {
                        updatePlay(algorithm,row,column,row,0,row,2,validCellPositions,currentBoard);
                    }
                    else if (column == 2)
                    {
                        updatePlay(algorithm,row,column,row,0,row,1,validCellPositions,currentBoard);
                    }

                    //vertical
                    if (row == 0)
                    {
                        updatePlay(algorithm,row,column,1,column,2,column,validCellPositions,currentBoard);
                    }
                    else if (row == 1)
                    {
                        updatePlay(algorithm,row,column,0,column,2,column,validCellPositions,currentBoard);
                    }
                    else if (row == 2)
                    {
                        updatePlay(algorithm,row,column,0,column,1,column,validCellPositions,currentBoard);
                    }

                    //Left diagnal
                    if (row == 0 && column == 0)
                    {
                        updatePlay(algorithm,row,column,1,1,2,2,validCellPositions,currentBoard);
                    }

                    else if (row == 1 && column == 1)
                    {
                        updatePlay(algorithm,row,column,0,0,2,2,validCellPositions,currentBoard);
                    }

                    else if (row == 2 && column == 2)
                    {
                        updatePlay(algorithm,row,column,0,0,1,1,validCellPositions,currentBoard);
                    }


                    //Right diagnal
                    if (row == 0 && column == 2)
                    {
                        updatePlay(algorithm,row,column,1,1,2,0,validCellPositions,currentBoard);
                    }

                    else if (row == 1 && column == 1)
                    {
                        updatePlay(algorithm,row,column,0,2,2,0,validCellPositions,currentBoard);
                    }

                    else if (row == 2 && column == 0)
                    {
                        updatePlay(algorithm,row,column,0,2,1,1,validCellPositions,currentBoard);
                    }
                }
            }
            catch(...)
            {
                continue;
            }
        }
    }
}


bool TicTacToeComputerPlayer::updatePlay(TicTacToeAlgorithmMoveType algorithm,
                                         int sourceRow,
                                         int sourceColumn,
                                         int firstRow,
                                         int firstColumn,
                                         int secondRow,
                                         int secondColumn,
                                         const std::vector<std::pair<int, int> > &validCellPositions,
                                         TicTacToeBoard &currentBoard)
{
    if (algorithm == TicTacToeAlgorithmMoveType::WinningMove &&
        playToWin(sourceRow,
                  sourceColumn,
                  firstRow,
                  firstColumn,
                  secondRow,
                  secondColumn,
                  currentBoard) == TicTacToeAlgorithmMoveType::WinningMove)
    {
        return true;
    }
    else if (algorithm == TicTacToeAlgorithmMoveType::BlockingMove &&
             playToBlock(sourceRow,
                         sourceColumn,
                         firstRow,
                         firstColumn,
                         secondRow,
                         secondColumn,
                         currentBoard) == TicTacToeAlgorithmMoveType::BlockingMove)
    {
        return true;
    }
    else if (algorithm == TicTacToeAlgorithmMoveType::RandomMove &&
             playRandomly(validCellPositions,
                          currentBoard) == TicTacToeAlgorithmMoveType::RandomMove)
    {
        return true;
    }
    return false;
}


TicTacToeAlgorithmMoveType TicTacToeComputerPlayer::playToWin(int row1,
                                                              int column1,
                                                              int row2,
                                                              int column2,
                                                              int row3,
                                                              int column3,
                                                              TicTacToeBoard &currentBoard) const
{
    TicTacToeCell sourceCell = currentBoard.getCell(row1,column1);
    TicTacToeCell otherCell1 = currentBoard.getCell(row2,column2);
    TicTacToeCell otherCell2 = currentBoard.getCell(row3,column3);

    //Check for winning condition
    if (otherCell1.getCellClass() == getPlayerClass() &&
        otherCell2.getCellClass() == getPlayerClass())
    {
        sourceCell.setCellClass(getPlayerClass());
        currentBoard.setCell(row1,column1, sourceCell);
        return TicTacToeAlgorithmMoveType::WinningMove;
    }
    return TicTacToeAlgorithmMoveType::NoMove;
}

TicTacToeAlgorithmMoveType TicTacToeComputerPlayer::playToBlock(int row1,
                                                                int column1,
                                                                int row2,
                                                                int column2,
                                                                int row3,
                                                                int column3,
                                                                TicTacToeBoard &currentBoard) const
{
    TicTacToeCell sourceCell = currentBoard.getCell(row1,column1);
    TicTacToeCell otherCell1 = currentBoard.getCell(row2,column2);
    TicTacToeCell otherCell2 = currentBoard.getCell(row3,column3);

    //Check for blocking condition
    if (otherCell1.getCellClass() != getPlayerClass() &&
        otherCell2.getCellClass() != getPlayerClass() &&
        otherCell1.getCellClass() != TicTacToePlayerClass::NoPlayer &&
        otherCell2.getCellClass() != TicTacToePlayerClass::NoPlayer)
    {
        sourceCell.setCellClass(getPlayerClass());
        currentBoard.setCell(row1,column1, sourceCell);
        return TicTacToeAlgorithmMoveType::BlockingMove;
    }
    return TicTacToeAlgorithmMoveType::NoMove;
}

TicTacToeAlgorithmMoveType TicTacToeComputerPlayer::playToOutsmart(int row1,
                                                                   int column1,
                                                                   TicTacToeBoard &currentBoard) const
{
         TicTacToeCell sourceCell = currentBoard.getCell(row1,column1);
         TicTacToeCell centerCell = currentBoard.getCell(1,1);

         TicTacToeCell otherCell1 = currentBoard.getCell(2,2);
         TicTacToeCell otherCell2 = currentBoard.getCell(0,1);
         TicTacToeCell otherCell3 = currentBoard.getCell(2,0);
         TicTacToeCell otherCell4 = currentBoard.getCell(0,0);

//         if (centerCell.getCellClass() == getPlayerClass() &&
//             row1 == )
//         {

//         }



}


TicTacToeAlgorithmMoveType TicTacToeComputerPlayer::playRandomly(const std::vector<std::pair<int,int> > &validCellPositions,
                                                                  TicTacToeBoard &currentBoard) const
{
    int selectedRow = 0;
    int selectedColumn = 0;
    if (getRandomAvailableCellPosition(selectedRow,selectedColumn,currentBoard))
    {
        try
        {
            TicTacToeCell selectedCell = currentBoard.getCell(selectedRow,
                                                              selectedColumn);
            selectedCell.setCellClass(getPlayerClass());

            currentBoard.setCell(selectedRow,
                                 selectedColumn,
                                 selectedCell);
            return TicTacToeAlgorithmMoveType::RandomMove;
        }
        catch (...)
        {
            return TicTacToeAlgorithmMoveType::EndOfGameMove;
        }
    }
}

bool TicTacToeComputerPlayer::getRandomAvailableCellPosition(int &rowOut,
                                                             int &columnOut,
                                                             const TicTacToeBoard &currentBoard) const
{
    std::vector<std::pair<int,int> > emptyCellPositions;
    for(const auto &cell : currentBoard.getCells())
    {
        int row = cell.getRow();
        int column = cell.getColumn();
        if (cell.getCellClass() == TicTacToePlayerClass::NoPlayer)
        {
            emptyCellPositions.push_back(std::make_pair(row,column));
        }
    }

    //No more spaces left on board. End of game
    if (emptyCellPositions.empty())
    {
        return false;
    }

    int min = 0;
    int max = static_cast<int>(emptyCellPositions.size()) - 1;
    int selectedRandomPosition = 0;
    if (min < max)
    {
        selectedRandomPosition = m_random.next(min,max);
    }
    rowOut = emptyCellPositions[selectedRandomPosition].first;
    columnOut = emptyCellPositions[selectedRandomPosition].second;
    return true;
}

TicTacToeComputerPlayer::~TicTacToeComputerPlayer()
{

}

}}}}//end namespace


