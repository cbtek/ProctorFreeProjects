/*
    UITicTacToeBoardController.cpp
    

*/
//----------------------------------------
//UITicTacToeBoardController.cpp generated by cbtek on 07-14-2017 at 01:35:37 AM
//----------------------------------------
#include "UITicTacToeBoardController.h"
#include "players/TicTacToeBasicComputerPlayer.h"
#include "TicTacToePlayerFactory.h"

#include <QTimer>

typedef pf_projects::products::tic_tac_toe::players::TicTacToeBasicComputerPlayer TicTacToeComputerPlayer;

namespace pf_projects {
namespace products {
namespace tic_tac_toe {

UITicTacToeBoardController::UITicTacToeBoardController(UITicTacToeBoardView *currentBoard)
{
    m_boardView = currentBoard;
    m_currentPlayerIndex = 0;
    m_lastPlayerToGoFirst = TicTacToePlayerClass::Player2;
    connect(m_boardView,SIGNAL(humanPlayRequested(int, int)),this,SLOT(onHumanPlayRequested(int,int)));
}

void UITicTacToeBoardController::initialize(TicTacToePlayerClass player1Class,
                                       TicTacToePlayerType player1Type,
                                       TicTacToePlayerClass player2Class,
                                       TicTacToePlayerType player2Type)
{
    m_players.clear();
    m_boardModel.initialize();
    m_boardView->reset();
    m_players.push_back(TicTacToePlayerFactory::create("player1",player1Class,player1Type));
    m_players.push_back(TicTacToePlayerFactory::create("player2",player2Class,player2Type));
    m_lastPlayerToGoFirst = (m_lastPlayerToGoFirst == TicTacToePlayerClass::Player1 ? TicTacToePlayerClass::Player2 : TicTacToePlayerClass::Player1);

    if (m_lastPlayerToGoFirst == TicTacToePlayerClass::Player2)
    {
        m_currentPlayerIndex = 1;
        int delay = m_random.next(250,1500);
        QTimer::singleShot(delay,this,SLOT(onComputerPlay()));
    }
    else
    {
        m_currentPlayerIndex = 0;
    }
}

UITicTacToeBoardController::~UITicTacToeBoardController()
{

}

void UITicTacToeBoardController::incrementPlayerIndex()
{
    ++m_currentPlayerIndex;
    if (m_currentPlayerIndex >= m_players.size())
    {
        m_currentPlayerIndex = 0;
    }
}

void UITicTacToeBoardController::onHumanPlayRequested(int row, int column)
{
    TicTacToePlayerPtr currentPlayer = m_players[m_currentPlayerIndex];
    if (currentPlayer->getPlayerType() == TicTacToePlayerType::Human)
    {
        TicTacToeCell playedCell = m_boardModel.getCell(row,column);
        playedCell.setCellClass(currentPlayer->getPlayerClass());
        m_boardModel.setCell(row, column, playedCell);

        if (currentPlayer->getPlayerClass() == TicTacToePlayerClass::Player1)
        {
            m_boardView->placeX(row, column);
            playOccured(row,column,TicTacToeTokenType::X);
            if (m_boardModel.isPlayerInWinState(TicTacToePlayerClass::Player1))
            {
                emit playerWonRound(TicTacToePlayerClass::Player1,
                                    TicTacToePlayerType::Human);
                return;
            }
        }
        else
        {
            m_boardView->placeO(row, column);
            playOccured(row,column,TicTacToeTokenType::O);
            if (m_boardModel.isPlayerInWinState(TicTacToePlayerClass::Player2))
            {
                emit playerWonRound(TicTacToePlayerClass::Player2,
                                    TicTacToePlayerType::Human);
                return;
            }
        }

        incrementPlayerIndex();

        if (m_boardModel.isBoardFull())
        {
             //Board is full and player did not win
            emit playerWonRound(TicTacToePlayerClass::None,
                                TicTacToePlayerType::None);
            return;
        }
        else
        {
            //Let the computer play a turn
            //Throw in a random delay to make it seem like
            //The computer is thinking.
            int delay = m_random.next(250,1500);
            QTimer::singleShot(delay,this,SLOT(onComputerPlay()));
        }
    }
    else
    {
        //ignore - Its not the "human" player's turn
    }
}

void UITicTacToeBoardController::onComputerPlay()
{
    TicTacToePlayerPtr currentPlayer = m_players[m_currentPlayerIndex];
    if (currentPlayer->getPlayerType() == TicTacToePlayerType::BasicComputer)
    {
       TicTacToeComputerPlayer *computerPlayer = dynamic_cast<TicTacToeComputerPlayer *>(currentPlayer.get());

        if (computerPlayer)
        {
            int playedRow;
            int playedColumn;
            TicTacToePlayResultType playResult = computerPlayer->play(playedRow,playedColumn,m_boardModel);
            if (playResult != TicTacToePlayResultType::NoMoreMovesPlay)
            {
                TicTacToeCell playedCell = m_boardModel.getCell(playedRow,playedColumn);
                playedCell.setCellClass(computerPlayer->getPlayerClass());
                m_boardModel.setCell(playedRow, playedColumn, playedCell);
                if (currentPlayer->getPlayerClass() == TicTacToePlayerClass::Player1)
                {
                    m_boardView->placeX(playedRow, playedColumn);
                    playOccured(playedRow,playedColumn,TicTacToeTokenType::X);
                    if (m_boardModel.isPlayerInWinState(TicTacToePlayerClass::Player1))
                    {
                        emit playerWonRound(TicTacToePlayerClass::Player1,
                                            TicTacToePlayerType::BasicComputer);
                        return;
                    }
                }
                else
                {
                    m_boardView->placeO(playedRow, playedColumn);
                    playOccured(playedRow,playedColumn,TicTacToeTokenType::O);
                    if (m_boardModel.isPlayerInWinState(TicTacToePlayerClass::Player2))
                    {
                        emit playerWonRound(TicTacToePlayerClass::Player2,
                                            TicTacToePlayerType::BasicComputer);
                        return;

                    }
                }

                incrementPlayerIndex();

                if (m_boardModel.isBoardFull())
                {
                     //Board is full and player did not win
                    emit playerWonRound(TicTacToePlayerClass::None,
                                        TicTacToePlayerType::None);
                    return;
                }
            }                        
        }
    }
}

}}}//end namespace


