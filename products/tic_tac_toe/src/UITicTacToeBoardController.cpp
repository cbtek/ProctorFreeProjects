/*
    UITicTacToeBoardController.cpp
    

*/
//----------------------------------------
//UITicTacToeBoardController.cpp generated by cbtek on 07-14-2017 at 01:35:37 AM
//----------------------------------------
#include "UITicTacToeBoardController.h"

#include "players/TicTacToeAdvancedComputerPlayer.h"
#include "players/TicTacToeTestComputerPlayer.h"

#include "TicTacToePlayerFactory.h"

#include <QTimer>

typedef pf_projects::products::tic_tac_toe::players::TicTacToeAdvancedComputerPlayer TicTacToeComputerPlayer;

namespace pf_projects {
namespace products {
namespace tic_tac_toe {

UITicTacToeBoardController::UITicTacToeBoardController(UITicTacToeBoardView *currentBoard)
{
    m_boardView = currentBoard;
    m_currentPlayerIndex = 0;
}

void UITicTacToeBoardController::initialize(TicTacToePlayerClass player1Class,
                                       TicTacToePlayerType player1Type,
                                       TicTacToePlayerClass player2Class,
                                       TicTacToePlayerType player2Type)
{
    m_boardModel.initialize();
    connect(m_boardView,SIGNAL(humanPlayRequested(int, int)),this,SLOT(onHumanPlayRequested(int,int)));
    m_players.push_back(TicTacToePlayerFactory::create("player1",player1Class,player1Type));
    m_players.push_back(TicTacToePlayerFactory::create("player2",player2Class,player2Type));
}

UITicTacToeBoardController::~UITicTacToeBoardController()
{

}

void UITicTacToeBoardController::onHumanPlayRequested(int row, int column)
{
    TicTacToePlayerPtr currentPlayer = m_players[m_currentPlayerIndex];
    if (currentPlayer->getPlayerType() == TicTacToePlayerType::Human)
    {
        TicTacToeCell playedCell = m_boardModel.getCell(row,column);
        playedCell.setCellClass(currentPlayer->getPlayerClass());
        m_boardModel.setCell(row, column, playedCell);

        if (currentPlayer->getPlayerClass() == TicTacToePlayerClass::Player1)
        {
            m_boardView->placeX(row, column);
        }
        else
        {
            m_boardView->placeO(row, column);
        }
        ++m_currentPlayerIndex;

        if (m_currentPlayerIndex >= m_players.size())
        {
            m_currentPlayerIndex = 0;
        }

        //Let the computer play a turn
        //Throw in a random delay to make it seem like
        //The computer is thinking.
        int delay = m_random.next(250,1500);
        QTimer::singleShot(delay,this,SLOT(onComputerPlay()));
    }
    else
    {
        //ignore - Its not the "human" player's turn
    }
}

void UITicTacToeBoardController::onComputerPlay()
{
    TicTacToePlayerPtr currentPlayer = m_players[m_currentPlayerIndex];
    if (currentPlayer->getPlayerType() == TicTacToePlayerType::AdvancedComputer)
    {
       TicTacToeComputerPlayer *computerPlayer = dynamic_cast<TicTacToeComputerPlayer *>(currentPlayer.get());

        if (computerPlayer)
        {
            int playedRow;
            int playedColumn;
            TicTacToePlayResultType playResult = computerPlayer->play(playedRow,playedColumn,m_boardModel);
            if (playResult != TicTacToePlayResultType::NoMoreMovesPlay)
            {
                TicTacToeCell playedCell = m_boardModel.getCell(playedRow,playedColumn);
                playedCell.setCellClass(computerPlayer->getPlayerClass());
                m_boardModel.setCell(playedRow, playedColumn, playedCell);
                if (currentPlayer->getPlayerClass() == TicTacToePlayerClass::Player1)
                {
                    m_boardView->placeX(playedRow, playedColumn);
                }
                else
                {
                    m_boardView->placeO(playedRow, playedColumn);
                }

                ++m_currentPlayerIndex;

                if (m_currentPlayerIndex >= m_players.size())
                {
                    m_currentPlayerIndex = 0;
                }
            }
        }
    }
}

}}}//end namespace


