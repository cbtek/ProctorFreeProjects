/*
    UITicTacToeBoardMain.cpp
*/
//UITicTacToeBoardMain.cpp generated by cbtek on 07-12-2017 at 02:23:37 AM

#include "UITicTacToeBoardMain.h"
#include "ui_UITicTacToeBoardMain.h"

#include <QPainter>

using namespace cbtek::common::utility;

using namespace pf_projects::products::qt_widget_animation_library;

namespace pf_projects {
namespace products {
namespace tic_tac_toe {

//These fields are used to determine the location of the
//content on the overal screen. The content is located towards
//the center of the Nuka-Boy image.  If those images change in size
//then the 1024/768 values will need to also change.

const static double c_X_POS_PERCENTAGE = 272 / 1024.0;
const static double c_Y_POS_PERCENTAGE = 78 / 768.0;
const static double c_WIDTH_AMOUNT = 480;
const static double c_HEIGHT_AMOUNT = 480;

UITicTacToeBoardMain::UITicTacToeBoardMain(QWidget *parent) :
    QWidget(parent),
    m_ui(new Ui_UITicTacToeBoardMain)
{
    m_ui->setupUi(this);    
    m_isMousePress = false;
    m_isStaticEnabled = true;
    m_isMusicEnabled = true;
    m_intMouseX = 0;
    m_intMouseY = 0;
    m_intContentX = 0;
    m_intContentY = 0;
    m_intContentW = 0;
    m_intContentH = 0;
    m_intXScore = 0;
    m_intOScore = 0;
    m_intDScore = 0;
    m_ptrBoardView = nullptr;
    m_ptrBoardController = nullptr;

    //Load images for nuka boy
    m_imgUnderlay.load(":/imgNukaBoyBase.png");
    m_imgOverlay.load(":/imgNukaBoyOverlay.png");
    m_imgBackground.load(":/imgNukaBoyBackground.png");

    //Load audio files
    m_audTokenPlay.setSource(QUrl("qrc:/audTokenPlay.wav"));
    m_audGameOver.setSource(QUrl("qrc:/audGameOver.wav"));

    //Depending on platform load the correct format.
    //I would prefer to use the ogg file since its
    //an open format and its half the size of the mp3.
    //Windows, ofcourse, is stupid and older versions
    //may not play ogg files.
#ifdef __WIN32
    m_audThemeMusic.setMedia(QUrl("qrc:/audThemeMusic.mp3"));
#else
    m_audThemeMusic.setMedia(QUrl("qrc:/audThemeMusic.ogg"));
#endif

    //Set audio volumes
    m_audTokenPlay.setVolume(100);
    m_audGameOver.setVolume(100);
    m_audThemeMusic.setVolume(50);

    //Initialize static animation effect
    m_ptrStaticAnimationOverlay = new UIStaticAnimation;
    m_ptrStaticAnimationOverlay->hide();
    connect(m_ptrStaticAnimationOverlay,SIGNAL(rendered(QImage)),this,SLOT(onStaticFrameRendered(QImage)));
    m_ptrStaticAnimationOverlay->start(64,255,60,32,QColor(0,255,0,26));

    //Set the current mode to startup
    m_currentMode = TicTacToeMode::Startup;

    //Reset the current state to "enter" transition
    m_currentState.reset();

    //Enable mouse tracking
    this->setMouseTracking(true);

    //Start the render/update loop
    this->startTimer(30);

}

void UITicTacToeBoardMain::setStaticEnabled(bool toggle)
{
    m_isStaticEnabled = toggle;
}

void UITicTacToeBoardMain::setMusicEnabled(bool toggle)
{
    m_isMusicEnabled = toggle;
    if (toggle)
    {
        m_audThemeMusic.setPosition(0);
        m_audThemeMusic.play();
    }
    else m_audThemeMusic.stop();
}

UITicTacToeBoardMain::~UITicTacToeBoardMain ()
{
    delete m_ui;
}

void UITicTacToeBoardMain::resizeEvent(QResizeEvent *event)
{
    //Resize the image buffer
    m_imgBuffer = QImage(width(),height(),QImage::Format_ARGB32);

    //Recompute the content width/height/xPos/yPos
    m_intContentX = static_cast<int>(c_X_POS_PERCENTAGE * width());
    m_intContentY = static_cast<int>(c_Y_POS_PERCENTAGE * height());
    m_intContentW = (width() / 1024.0) * c_WIDTH_AMOUNT;
    m_intContentH = (height() / 768.0) * c_HEIGHT_AMOUNT;    

    //If the board view ptr is valid then update the board size with
    //new content width and height
    if (m_ptrBoardView)
    {
        m_ptrBoardView->updateBoardSize(m_intContentW,m_intContentH);
    }

    //Update to repaint screen
    this->update();
}

void UITicTacToeBoardMain::paintEvent(QPaintEvent *event)
{
    //What a pretty paintEvent.  Everything is drawn to the m_imgBuffer,
    //so this is all the coded needed.
    QWidget::paintEvent(event);
    QPainter g(this);
    g.drawImage(0,0,m_imgBuffer);
}

void UITicTacToeBoardMain::mouseMoveEvent(QMouseEvent *event)
{
    //Calculate the actual local content position
    m_intMouseX = event->pos().x() - m_intContentX;
    m_intMouseY = event->pos().y() - m_intContentY;
}

void UITicTacToeBoardMain::mousePressEvent(QMouseEvent *event)
{
    //Calculate the actual local content position
    m_intMouseX = event->pos().x() - m_intContentX;
    m_intMouseY = event->pos().y() - m_intContentY;

    //Set mouse pressed boolean to true
    m_isMousePress = true;
}

void UITicTacToeBoardMain::timerEvent(QTimerEvent *event)
{
    //Set up painter to draw to the image buffer
    QPainter painter(&m_imgBuffer);

    //Calculate the total screen extents
    QRect screenRect(0,0,m_imgBuffer.width(),m_imgBuffer.height());

    //Calculate the extents of the content area
    QRect contentRect(m_intContentX, m_intContentY, m_intContentW, m_intContentH);    

    //Draw the blurred background (This is kinda how fallout does it when looking at the PipBoy)
    painter.drawImage(screenRect, m_imgBackground);

    //Draw the Nuka-Boy Base Underlay image
    painter.drawImage(screenRect, m_imgUnderlay);

    //Update the state machine based on which mode we are currently in
    switch(m_currentMode)
    {
        case TicTacToeMode::Startup:updateStartupMode(painter);break;
        case TicTacToeMode::Game:updateGameMode(painter);break;
        case TicTacToeMode::GameOver:updateGameOverMode(painter);break;        
    }

    //If static is enabled then show it before drawing actual overlay
    if (m_isStaticEnabled)
    {
        painter.drawImage(contentRect,m_imgCurrentStaticFrame);
    }

    //Draw the screen overlay.
    painter.drawImage(screenRect,m_imgOverlay);

    //Repaint the screen
    this->update();
}

// The next methods handle the transitions for multiple states/modes
// There are three transitions:
// 1) Enter Transition - Occurs only once, when mode is initially set
// 2) Update Transition - Occurs multiple times
// 3) Exit Transition - Occurs only once, when mode is set to another

void UITicTacToeBoardMain::updateStartupMode(QPainter &painter)
{
    switch(m_currentState.getTransition())
    {
        //////////////////////////////////
        case Transition::Enter:
        {
            if (m_imgStartupContent.isNull())
            {
                m_imgStartupContent.load(":/imgNukaBoyLogo.png");
            }
            m_audThemeMusic.play();
            m_tmStartupTimeOut.restart();
            m_currentState.setNextTransition();
        }
        break;
        //////////////////////////////////
        case Transition::Update:
        {
            QRect contentRect(m_intContentX, m_intContentY, m_intContentW, m_intContentH);
            painter.drawImage(contentRect,m_imgStartupContent);
            if (m_isMousePress)
            {
                m_currentState.setNextTransition();
                m_isMousePress = false;
            }
        }
        break;
        //////////////////////////////////
        case Transition::Exit:
        {
            m_currentState.setNextTransition();
            m_currentMode = TicTacToeMode::Game;
        }
        break;
        //////////////////////////////////
    }
}

void UITicTacToeBoardMain::updateGameMode(QPainter &painter)
{
    switch(m_currentState.getTransition())
    {
        //////////////////////////////////
        case Transition::Enter:
        {            
            if (!m_ptrBoardView)
            {
                m_ptrBoardView = new UITicTacToeBoardView;
                connect(m_ptrBoardView,SIGNAL(repaintRequested()),this,SLOT(onRepaintBoard()));
            }

            if (!m_ptrBoardController)
            {
                m_ptrBoardController = new UITicTacToeBoardController(m_ptrBoardView);
                connect(m_ptrBoardController,
                        SIGNAL(playerWonRound(TicTacToePlayerClass, TicTacToePlayerType)),
                        SLOT(onPlayerWon(TicTacToePlayerClass,TicTacToePlayerType)));

                connect(m_ptrBoardController,
                        SIGNAL(playOccured(int, int, TicTacToeTokenType)),
                        this,
                        SLOT(onPlayOccured(int, int, TicTacToeTokenType)));
            }

            m_ptrBoardController->initialize();
            m_ptrBoardView->updateBoardSize(m_intContentW,m_intContentH);
            m_currentState.setUpdate();
        }
        break;
        //////////////////////////////////
        case Transition::Update:
        {
            QRect contentRect(m_intContentX, m_intContentY, m_intContentW, m_intContentH);
            m_ptrBoardView->drawBoard(contentRect, painter);
            if (m_intMouseX >= 0 && m_intMouseY >= 0)
            {                
                m_ptrBoardView->updateBoardMousePosition(m_intMouseX,m_intMouseY);
                if (m_isMousePress)
                {
                    m_ptrBoardView->updateBoardMouseClick(m_intMouseX,m_intMouseY);
                    m_isMousePress = false;
                }
            }
        }
        //////////////////////////////////
        break;
        case Transition::Exit:{}
        break;
    }
}

void UITicTacToeBoardMain::updateGameOverMode(QPainter &painter)
{
    switch(m_currentState.getTransition())
    {
        //////////////////////////////////
        case Transition::Enter:
        {
            m_currentState.setNextTransition();
            m_audGameOver.play();
        }
        break;
        //////////////////////////////////
        case Transition::Update:
        {
            QRect contentRect(m_intContentX, m_intContentY, m_intContentW, m_intContentH);
            painter.drawImage(contentRect,m_imgGameOverContent);
            if (m_intMouseX >= 0 && m_intMouseY >= 0)
            {
                if (m_isMousePress)
                {
                    m_currentMode = TicTacToeMode::Game;
                    m_currentState.reset();
                    m_isMousePress = false;
                }
            }
        }
        break;
        //////////////////////////////////
        case Transition::Exit:
        {
            m_currentState.setNextTransition();
        }
        break;
    }
}

void UITicTacToeBoardMain::onPlayerWon(TicTacToePlayerClass playerClass,
                                       TicTacToePlayerType playerType)
{
    //Increment the scores of players who won
    if (playerClass == TicTacToePlayerClass::Player1)
    {
        ++m_intXScore;
    }
    else if (playerClass == TicTacToePlayerClass::Player2)
    {
        ++m_intOScore;
    }
    else ++m_intDScore;


    //Send the scores to the main user interface to display
    emit scoresUpdated(m_intXScore,
                       m_intOScore,
                       m_intDScore);


    //Set current mode and reset the current state to the "Enter" transition
    m_currentMode = TicTacToeMode::GameOver;
    m_currentState.reset();

    //Depending on who won/loss set the appropriate image
    if (playerType == TicTacToePlayerType::Human)
    {
        m_imgGameOverContent.load(":/imgWinScreen.png");
    }
    else if (playerType == TicTacToePlayerType::BasicComputer)
    {
        m_imgGameOverContent.load(":/imgLooseScreen.png");
    }
    else
    {
        m_imgGameOverContent.load(":/imgDrawScreen.png");
    }

}

void UITicTacToeBoardMain::onStaticFrameRendered(QImage frame)
{
    m_imgCurrentStaticFrame = frame;
}

void UITicTacToeBoardMain::onRepaintBoard()
{
    this->update();
}

void UITicTacToeBoardMain::onPlayOccured(int row, int column, TicTacToeTokenType tokenType)
{
    //Could do more intereseting things here, but for now just play the token sound.
    m_audTokenPlay.play();
}

}}}//end namespace

